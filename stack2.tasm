# stack routines with interactive junk
# uses stack1 code, modified for bstack to grow down.

# keys:
# +0-	type number
# enter	push number
# p   	pop and display number
# d   	dump stack

### limits needs and details:

## stack:
# namespace:
#	stack* push pop
#	bstack* bpush bpop
# after push and pop if needed, restore reg1 like this:
#	romread1;>stackreg1bak

#>>>>>> to do
# switch bstack to grow down too
# Â¿switch to stackpt?
# copy in tritin
# modify key_enter routine to push to stack
# add p and d key routines
# display key usage at start, add h key
# maybe then add some math ops


gotodata;>stackinit

# stack pointer etc
null;+++++++++;stackbase
null;;stacktop
null;;stackreg1bak
null;+++------;bstackbase
null;;bstacktop

# some bstackbase values with space for
# the 2 stacks and remaining memory:
# +++------	728  		18955
# ++-------	2186		17497
# +--------	6560		13123


romread1;>stackbase;stackinit
setdata;>stacktop
# if not using bstack omit remainder
romread1;>bstackbase
setdata;>bstacktop
# underflow marker for bstack, may help in debugging;
# 2 lines doubly optional:
setreg1;-+-+-+-+-
gotodata;>bpush

gotodata;BROKE_HERE

##########################
### stack dump routines
# can't use continue because they have loops.

romread1;>stacktop;stackdump
setreg2;00000000-;stackdumploop
subtract
setdata;>stackdump1
romread2;000000000;stackdump1
dumpreg2
romread2;>stackbase
gotodataif;>stackdumpdone
gotodata;>stackdumploop
null;;stackdumpdone

# >>> insert return code

stop


##########################
### other example code

## subroutine call

# call:
setreg1;>retpt
gotodata;>push
gotodata;>subr
null;;retpt

# note registers trashed by the push before the call.
# they could be reloaded between the two gotodatas.

null;;subr
# ...
# return:
gotodata;>pop
gotoreg1

## to reset the stack, copy stackinit


############################
### main stack routines

## push
# pushes reg1 to the stack
# trashes reg1, reg2

setdata;>stackreg1bak;push

romread1;>stacktop
setdata;>stackpushme
romread1;>stackreg1bak
setdata;000000000;stackpushme

romread1;>stacktop
setreg2;00000000-
add
setdata;>stacktop

continue

## pop
# pops top of stack into reg1
# trashes reg2

romread1;>stacktop;pop
setreg2;00000000-
subtract
setdata;>stacktop
setdata;>stackpopme
romread1;000000000;stackpopme
continue


##########################
### b stack routines
# optional

## push
# pushes reg1 to b stack
# trashes reg1, reg2

setdata;>stackreg1bak;bpush
romread1;>bstacktop
setdata;>bstackpushme
romread1;>stackreg1bak
setdata;000000000;bstackpushme
romread1;>bstacktop
setreg2;00000000+
add
setdata;>bstacktop
romread1;>stackreg1bak
continue

## pop
# pops top of b stack into reg1
# trashes reg2

romread1;>bstacktop;bpop
setreg2;00000000+
subtract
setdata;>bstacktop
setdata;>bstackpopme
romread1;000000000;bstackpopme
continue


stop
