instruction reference:
../textdocs/programming-the-VM/SBTCVM-asm.txt
../textdocs/instructionlist.txt
assembler source: ../SBTCVM-asm2.py
grep -n __ ../textdocs/programming-the-VM/* ../textdocs/*

would like to fix assembler, it doesn't check syntax.

../ROMS/
../VMSYSTEM/ROMS/
grep -n __ ../VMSYSTEM/ROMS/*.tasm ../ROMS/*.tasm ../ROMS/oldroms/*.tasm *.tasm

../VMSYSTEM/ROMS/fib.tasm
	big example
../ROMS/addloop.tasm
	instruction speed test: 19682 * 5 = 98410 instructions in 3 seconds.
	about 33kips then.

>>choose license

what's this?
../textdocs/IObanklist-full.txt
../textdocs/IObanklist-summary.txt

multi-trom: the .streg files in ../VMSYSTEM/ROMS/


@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@ PROGRAMS

ideas and actual work, the latter marked with '$'.
to-do marked with '>'.

~ stock code
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
$ trit input
	tritin.tasm
$ stack
	vital! there is no stack and only single-level return. (continue.tasm)
	$ stack1.tasm -- base with tests
	$ stack1pt.tasm -- stack1 rewritten with pt* instructions.
	> stack2.tasm -- interactive with tritin
interrupt routines
	* example structure for enabling/disabling interrupts
	* routines to push everything on interrupt, and restore it at end.
7-seg display
	for easy score display in games
string handling
	input from keyboard
	output to tty
	integer<->balanced ternary string conversion
	integer<->decimal string conversion
directional movement key routines
draw string in graphics mode(s)
linked list traverser

~ simple programs
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
$ character set display
	chars.tasm
	> working on paged number:character display.
palette in the color framebuffer
	lots of offsetlen work i'm sure, good practice for 
	font drawing and other graphic region copying.
calculator, tty display
	calculation operations could easily be added to stack2
	for a rpn calculator.
calculator, graphical display
clock, digital
	7-seg in the mini color display
clock, analogue
	easy enough with the vector graphics in the mini displays

~ games
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
simple: key response; single-pixel drawing; no timing; trivial generator
	robots
	black box
simple running as above, but perhaps more coding work
	hangman
		word list needs composition and several routines.
	unequal
	towers
	magnets
	unruly
	others from sgt puzzles
		all need cursor and/or x/y addressing.
other
	snake
		timing, key response, simple drawing
	moon buggy
		timing, key response, 'blitting' when the buggy jumps or crashes
	
get ideas for some above from bsd games:
	https://cvsweb.openbsd.org/cgi-bin/cvsweb/src/games/
	i think snake game is 'worm'.
others from sgt puzzles:
	???

~ complex programs
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
forth
	forth.txt
text editor
	with the forth
binary computer emulator XD


@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@ WANTED

not asking, keeping track of what i hope i can add some day.

~ interruptable wait
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
probably the simplest key to sane interrupt handling.
see 'threading' in the next section.

~ save trom
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
probably the simplest way to get permanent storage.
it'll overwrite, preserving data is the user's responsibility.
i use git, or files can be copied of course, and in case of 
disaster the original trom can be restored by assembling again.

~ disassembler
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
to go with saving the trom. apart from disassembly itself, 
its most useful function may be finding strings in the trom, 
and translating them to ascii.
i'm thinking it could remember the last data cells so long as 
every one corresponds to a character. when non-character data 
is encountered, if more than n cells are saved, they are written 
into the disassembly in a format similar to textstart/textstop.


@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@ HOWTO

techniques, not hardware access.

~ emulate indirect addressing
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
stack1.tasm does it like this:
	romread1;>stacktop
	setdata;>stackpushme
	romread1;>stackreg1bak
	setdata;000000000;stackpushme
pt* are probably better.
	see -asm.txt (which is now updated with them) and 
	../ROMS/testmempt.tasm
	

~ jumps, loops, conditionals
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
so important i'm putting them here.
cmd|data|label
	define label. data required in this case.
gotodata|>label
	obvious
gotoreg1
	register index yay!
	not used in any stock roms. works fine though.
gotodataif|>label
	jump if reg1 == reg2
gotoifgreater|>label
	jump if reg1 > reg2
../ROMS/addloop.tasm
stack1.tasm:/stackdump

~ copy memory region
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
? :)


~ trit manipulation
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
offsetlen
	../ROMS/testoffsetlen.tasm
	../textdocs/programming-the-VM/SBTCVM-asm.txt:/offsetlen
	../textdocs/programming-the-VM/offsetlength.txt
	looks like it affects all future ops until re-set.
	which ops exactly? "load and set." which are those? :)
	certainly memory read and write. anything else?
offsetlen|A,B,C
	A: if on, existing destination data is ignored, 
		ground is written for trits not covered by the source.
		otherwise the destination trits are preserved.
	B: offset from the radix point
		so shift left? no, left edge to truncate.
	C: truncation
truncation may be greater than the number of chars without affecting it.
offsetlen.tasm
new description:
[offsetlen defines a masking window, only trits visible 
through the window are written to the destination.

usage:
	offsetlen|A,B,C
if A is "off", the remaining trits in the destination are preserved.
if it is "on", they are overwritten with 0.
B is the offset for the window's low-value edge (the right side).
C is the size of the window, the length extending toward high values.
affected operations are read and write to IO and memory.
the window remains active until reset with "offsetlen|off,0,9".
see also: romread* setdata IOread* IOwrite*
]

~ threading
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
this seemed like something i wasn't going to bother with, 
until i realised it might be a way around the problems with 
interrupts. maybe all the key input could be handled by 
one thread, (the main thread is the only one which can,)
while all the actual action happens in another thread.
nnnope! you have to have a running mainloop -- no "wait" -- 
for key interrupts to work properly, and that would halve the 
speed of the other thread.


@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@ KEYBOARD

interrupt per key only, i think. ridiculous, but not painful.
available keys: 
	1-9 + - a-z space enter

reuse or reference ../ROMS/keytest.tasm , it's got all the keys.
i may as well write python code to generate my own keyboard interrupt table.

DOC BUG:
../textdocs/programming-the-VM/keyboard-inter.txt
	does not give the asm names.
	(it's not a useful document for me until i want to write an assembler)

@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@ FRAMEBUFFER GRAPHICS

choice of low res or very low res. :)
low res:
* 114 x 81 x 1-trit mono = 9234 trits = 5% of a 'rom'
* 114 x 81 x 3 trit color = 27702 trits = 16% of a 'rom'
very low res:
* _ x _ x 1-trit mono = _ trits = _% of a 'rom'

requires explicit update. see a generated trom.

~ tritmaps
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
how to copy?
there are pointer operations using r1. i'm sure it's possible using this.

~ drawing text
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
there's not much room.
6x7 pixel chars = 19x11 colsXrows
6x8 = 19x10
6x6 = 19x13

~ expansionism
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
i thought of taking the low res mono and 3x3-ing it.
it would take up half (47%) of a 'rom'.
it might be reasonable if one 'rom' is a display server.
it would allow 57x34 or 57x30 chars, depending on 6x7 or 6x8 char cell.
non-square pixels might be more reasonable, but all this is still underwhelming.
another trick: 2 trits encoding 3 pixels. i'm sure i'd hate it. :)

~ roms
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
../ROMS/invertdemo1.tasm
	writes to display memory

@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@ SIDE GRAPHICS

~ colors & blanking
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
colorfill;color
	blank it with the color
setcolorreg;color
	set the color to draw with
monofill;???????mm
	blank it with shade 'mm'

'color' here is 6 trit rgb. it may be specified as e.g. 255,255,255

~ drawing operations
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
colorpixel;???xxxyyy
setcolorvect;???xxxyyy
colorrect;???xxxyyy
colorline;???xxxyyy
monopixel;???xxyymm
setmonovect;???xxyy??
monorect;???xxyymm
monoline;???xxyymm
../VMSYSTEM/ROMS/intro.tasm:/TTYclear..vectdemo
	

@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@ TTY

72x27 or 72x54
